#include <exception>
#include <iostream>
#include <ostream>

class Product {
	public:
		Product() = default; // default constructor
		Product(const Product&); // copy constructor
		Product(Product&&); // move constructor

		Product& operator=(const Product&) = default;
		Product& operator=(Product&&) = default;
		// deconstuctor is not declared, should be generated by compiler
	public:
		// A combination of setters and getters (without any actual input modification)
		void set_name(const std::string& name) { this->name_ = name; };
		std::string name() const { return this->name_; };

		void set_availability(bool b) { this->available_ = b; };
		bool available() const { return this->available_; };

		void set_price(double price) { this->price_ = price; };
		double price() { return this->price_; };

		void set_rating(int rate) { this->rating_ = rate; };
		int rating() { return this->rating_; };

		void display_info() { 
			try {
				std::cout << "Product: " << this->name_ << " |\n Price: $" << this->price_ << std::endl;
			} catch (std::exception e) {
				std::cout << "std::ostream error inside Product class" << std::endl;	
			}
	}
	private:
		// The private variables that the setters modify and the getters obtain
		std::string name_;
		double price_;
		int rating_;
		bool available_;
};


// ostream and istream operator overloading not yet implemented
std::ostream& operator<<(std::ostream&, const Product&);
std::istream& operator>>(std::istream&, Product&);

Product create_apple() {
	Product apple;
	apple.set_name("Red apple");
	apple.set_price(0.2);
	apple.set_rating(5);
	apple.set_availability(true);
	return apple;
}

class Warehouse {
	public:
		Warehouse() : size_{0}, capacity_{1000}, products_{nullptr}
		{
			products_ = new Product[capacity_];
		}
		
		~Warehouse() {
			delete [] products_;
		}
		Warehouse(const Warehouse& rhs) {  // *Deep* copy constructor in instances like
		// Warehouse w2 = w1;
			size_ = rhs.size_;
			capacity_ = rhs.capacity_;
			products_ = new Product[capacity_];
			for (int ix = 0; ix < size_; ++ix) {
				products_[ix] = rhs.products_[ix];
			}
		}
		void list_items() {
			for (int ix = 0; ix < this->size_; ++ix) {
				this->products_[ix].display_info();
			}
		}
		Warehouse operator+(const Warehouse& b) {
			Warehouse sum; // temporary
			sum.size_ = this->size_ + b.size_;
			sum.capacity_ = this->capacity_ + b.capacity_;
			sum.products_ = new Product[sum.capacity_];
			for (int ix = 0; ix < this->size_; ++ix) {
				sum.products_[ix] = this->products_[ix]; }
			for (int ix = 0; ix < b.size_; ++ix) {
				sum.products_[this->size_ + ix] = b.products_[ix]; }
			return sum;
		}
	public:
		void add_product(const Product& p) {
			if (size_ == capacity_) { /* resize */ }
			products_[size_++] = p;
		}
	private:
		int size_;
		int capacity_;
		Product* products_;
};


int main() {
	Warehouse small;
	Warehouse mid;
	Product book;
	Product chastity_cage;
	chastity_cage.set_name("Cheese Grater");
	chastity_cage.set_price(5.36);
	book.set_name("The Fault in Our P0rn Stars");
	book.set_availability(true);
	book.set_price(19.99);
	small.add_product(book);
	mid.add_product(chastity_cage);

	// Operator overloading example
	Warehouse large{small + mid};
	large.list_items();  // Throws error due to lacking std::ostream& operator<<() implementation

}
